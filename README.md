# BuketFlower_Client

버킷플라워 프로젝트는 사용자가 평소에 하고싶거나 도전해보고 싶었던 버킷리스트를 기록하고
달성에 대한 보상으로 여러 종류의 꽃을 받아 자신만의 식물을 가질 수 있게 만드는 프로젝트 입니다.

## 2022-09-17 Things to Develop

사용자가 보상으로 받은 꽃들을 '나의 버킷플라워 메뉴'에 저장되고, 이 보상들을 컨테이너에 넣어 꾸밀 수 있는 기능필요.

컨테이너와 같은 페이지에 있는 '나의 버킷플라워 메뉴'에서 드래그앤드랍으로 꽃들을 컨테이너 위에 놓을 수 있는 것까지 구현.

이후 로그인시에도 사용자가 자신이 이동시킨 위치에서 똑같은 꽃들을 볼 수 있게 하려면 컨테이너 안으로 이동시킨 꽃들의 위치값을 저장해서 사용자가 재접속 후 버킷플라워 메뉴로 이동할 시에도 같은 위치에 같은 꽃들을 다시 렌더링 되게 구현해야함.

브라우저 전체에서 꽃 하나하나가 가지고 있는 절대적인 위치를 저장하는 방식은 브라우저 크기 변화에 대응을 할 수 없는 문제가 있음.

'버킷플라워 컨테이너'에 상대적인 위치를 정하는 것으로 해결할 수 있으나 마크업구조상 '나의 버킷플라워 메뉴'는 '버킷플라워 컨테이너'에 자식태그로 들어가있지 않고, 버킷플라워 메뉴를 컨테이너 하위로 옮기는 형태로 마크업 하기에도 어려움이 있음.

useRef Hook으로 컨테이너가 가진 left값을 가져와서 사용자가 컨테이너 위에 꽃을 놓는 순간의 마우스x,y값에서 빼주면 꽃이 컨테이너를 기준으로 어디있냐 하는 위치값을 알 수 있게 됨. 이 위치값을 db에 저장한 후에 사용자가 개인 페이지로 접속할 때마다 해당 위치에 꽃을 렌더링 해주면 사용자가 컨테이너 위로 옮긴 꽃을 이후에도 같은 위치에서 보여줄 수 있음.

하지만 근본적으로, 추후 사용자가 꾸민 버킷플라워를 이미지로 추출 해야할 상황과 사용자가 꽃을 컨테이너 위로 옮긴 이후에도 '나의 버킷플라워 메뉴'에서는 사용자가 보유한 꽃을 계속해서 보여줄 수 있어야 함.

결국 컨테이너 태그 하위에 꽃 이미지들을 배치하는 것이 가장 좋은데, 이것은 사용자가 놓은 꽃의 위치값과 id, 파일이름을 배열로 받아서 db에 저장하고 사용자가 개인페이지에 접속할 때 위치값과 id, 파일이름을 매치시켜 꽃의 이미지를 한 번 더 렌더링 하는 로직을 통해 구현해야함.

'나의 버킷플라워 메뉴'의 사용자가 가진 꽃들이 map메서드로 구현되어 있기때문에 배열방식으로 처리되는 것을 고려해야함.
사용자가 같은 파일이름을 가진 같은 꽃을 여러개 가지고 있는 상황이라면 컨테이너 위에 있는 같은 이미지의 꽃들이 서로 다른 꽃임을 어떻게 구분할지도 고민해야함. (아마도 배열에 id값을 주는 방식으로? map의 index값은 꽃이 삭제되거나 하는 수정상황에서 변하게 되니 사용할 수 없을 것 같다.)

---

'나의 버킷플라워 메뉴'에서 '버킷플라워 컨테이너'로 꽃을 드래그앤드롭할 때 onDrop이나 onDragEnd이벤트 핸들러의 위치값을 받아서 배열에 저장해놓았다가 사용자가 '저장하기'버튼을 클릭했을 때 db로 위치값, id, 파일이름, userid를 INSERT 하고 이 값들을 다시 불러와서 '버킷플라워 컨테이너'의 하위 엘리먼트로 만든다.

'나의 버킷플라워 메뉴'를 map으로 만들때 db에서 받아온 배열 중 index가 일치하는 것이 있으면 opacity를 낮춰서 이미 사용된 꽃임을 알린다.

컨테이너 위에 있는 꽃을 삭제하고 '나의 버킷플라워 메뉴'로 되돌릴 수 있는 기능도 구현 필요.

## 2022-09-18 Issues

fixed속성을 준 모달창이 뷰포트가 아닌 userBoard 엘리멘트에 종속되는 문제 발생.

animation-fill-mode를 사용할 때 forward 속성이 position 속성을 망가뜨릴 수 있다는 것에 주의해야한다.
정확한 작동 원리는 모르지만, 아마도 forward라는 속성이 단순히 css를 유지해주는 것만이 아니라, 자체적으로 애니메이션이 종료되는 시점의 속성을 가지는 뷰포트를 새로 만드는 것 같았다.

엘리멘트가 원래대로 돌아오는 애니메이션에 forward속성을 넣을 경우 애니메이션이 작동하기 전 상태로 유지되는 것이 아니라 새로운 상태가 만들어지고, position : fixed는 뷰포트가 아닌 애니메이션 속성이 작성된 엘리먼트를 기준으로 정렬된다.

## 2022-09-19 Issues

delete버튼의 구현이 필요하여 div를 draggable하게 설정하고 해당 div의 하위에 꽃이미지와 delete아이콘을 배치했는데 div의 background가 뒤쪽 엘리먼트의 색으로 변하는 문제가 있었다. 구글링 결과 draggable이 설정된 엘리먼트에 이슈를 transform: translate(0, 0)을 주는 방식으로 해결했지만 이게 어떤방식으로 작동되길래 해결이 된 건지는 감도 안 잡힌다.

https://stackoverflow.com/questions/55668944/is-it-possible-to-remove-background-color-when-dragging-png-image

---

기존에는 드래그앤드랍을 구현할 때 onDrag상태에서 계속 갱신되는 엘리먼트의 좌표를 실시간으로 담는 전역변수를 설정했지만, 도중에 setState를 사용할 일이 생겼고, 이후 리렌더링하면 전역변수가 초기화되는 문제가 발생했다. 해결하기 위해서 전역변수를 따로 선언하지 않고 state로 관리하는 방법을 시도했는데, 이번에는 드래그하는 엘리먼트에 잔상이 보이는 현상이 생겼다. 추측하기로는 드래그할 때마다 밀리초 단위로 리렌더링이 일어나게 되고, 같은 setState가 순간적으로 매우 여러번 발생할 경우 일부만 실행시키는 리액트의 작동 원리 때문에 이렇게 된 것 같은데 이런 방식을 사용하기 전에도 리렌더링문제 때문에 onDrag에 setState를 사용하기 싫었다. 아직 해결하지는 못했지만 onDrag콜백에서 setState를 사용하지 않도록 들어내고 전역변수 초기화 문제는 drop시에 전역변수에 담긴 것을 한 번 만 state에 담는 방법을 생각하고 있다. 이외에도 라이브러리를 사용하면 깔끔할 수도 있겠지만 여유가 없어서 일단 놔두는 중.

## 2022-09-21 Issues

컨테이너에 꽃을 추가한 다음 저장한 후 바로 수정창으로 들어가서 해당 꽃을 다시 삭제하면 저장했을 때 삭제가 되지 않는 버그가 있었는데 splice메서드의 작동원리와 관련이 있는 버그로 보인다. 이번 버그를 수정하면서 알게된 것은 일단 splice메서드는 함수의 인자로서 사용될 수 없다는 것이다. 콘솔로도 찍을 수 없고, setState메서드에서도 작동하지 않는다. 정확히 말해 작동하지 않는다기 보다는 splice(4,1)이 index가 4인 곳부터 하나의 열을 지우지 않고 4,1의 수를 찍어오는 방식으로 작동하게 된다는 것이다.

즉 array = [1, 2, 3, 4]라는 배열에서
array.splice(2,1)의 값은 [1, 2, 4]이고
console.log(array.splice(2,1))의 값은 [3]이 된다.

함수의 인자로 들어갈때의 splice의 작동방식이 변한다는 것을 알게 되었지만, 원인에 대해서는 추후에 찾아봐야겠다.

참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

## 2022-09-21 Issues

추가된 순서가 다른 branch category의 엘리먼트와 purple category의 엘리먼트가 FlowerContainer에 drop되지 않는 문제 발생. index와 arr의 차이에서 발생했다고 생각되지만 정확히 알 수 없어서 계속 원인을 찾는 중.

---

문제는 단순했는데, onDragEnd시에(여기서는 onDrop을 사용하지 않고 onDragEnd만 사용. onDargOver에 대한 이해가 부족하기도 하고 순서차이 이외에 onDrop과 onDragEnd가 어떤 차이가 있는지 아직 잘 느끼지 못함.) 불러오는 useRef의 배열넘버가 index로 되어있어 purple category의 첫 번재 엘리먼트는 index 0을 불러왔고, 이는 곧 ref배열에서 첫번째 즉, 전체에서 첫 번째인 redbranch를 불러오는 결과가 되었다. 같은 방식으로 branch category의 마지막 엘리먼트는 본인의 index 7을 불러왔고, 8번째로 추가된 purple category의 첫 번째 엘리먼트를 불러온 것이다.

Personal.js에 도저히 읽기 힘들 정도로 모든 코드가 때려박아져 있는 게 결국 화근이 됐다. 다른 컴포넌트나 하다못해 유틸함수가 나누어져 있었더라면 생각보다 금방 찾을 수 있었을지도 모른다. 코드가 1500줄이 되어버리니 index넘버를 arr - 1로 수정하는 과정에서 ref를 건너뛰게 된 것이다.

## 2022-10-04 Issues

플라워 컨테이너를 다시 확인해보니 로테이트된 엘리먼트는 left와 top의 기준점이 달라져서 저장 후 displayed로 rewards를 불러올 때 위치가 바뀌는 현상이 있었다. 회전된엘리먼트는 자신만의 left와top을 갖는 것이 아닌 회전 이전을 기준으로 left와 top이 결정되는데 displayed에서 이 기준을 제대로 잡아줘야 한다. 사실 ondrop함수를 설계할 때 잘 모르고 설계해서 일어난 버그로, e.target.offsetLeft + e.clientX - dropedLocation.clientX로 회전 이전 기준으로 위치를 받아올 수 있었는데 posx: e.clientX + clientLeft - boxLeft로 사용해버리는 바람에 이러한 문제가 생긴 것.
